// 时间复杂度，空间复杂度知识要点
// 复杂度分析是整个算法学习中的精髓，掌握了时间空间复杂度分析，就掌握了数据结构和算法一半的精华。

// 为什么不直接通过终端代码运行，检测代码的执行效率？
//  直接在终端运行代码的方式可以叫做事后统计法，它的主要缺点如下：
// 1、代码的测试结果非常依赖测试环境。不同的硬件设备的运行时间会有差别，无法区分代码自身性能的优劣。
// 2、代码测试结果受数据规模的影响很大。数据规模的大小会直接影响代码的运行效率，当数据量很小时，许多
// 高性能的算法反而无法显示自身的优势。

// 利用大O复杂度表示法，可以将算法的性能抽离出来，粗略地估计算法的性能。
// 所有代码的执行时间T(n)与每行代码的执行次数成正比。
// 代码示例：
int cal(int n) {
	int sum = 0;
	int i = 1;
	int j = 1;
	for(; i <= n; ++i) {
        j = 1;
		for(; j <= n; ++j) {
			sum = sum + i*j;
		}
	}
}
// 整段代码的总执行时间为T(n) = (2n2+2n+3)

// 时间复杂度分析原则
// 1、只关注循环执行次数最多的一段代码
// 2、加法法则：总时间复杂度等于量级最大的那段代码的时间复杂度
// 3、乘法法则：嵌套代码的时间复杂度等于嵌套内外代码时间复杂度的乘积

// 常见时间复杂度
// 多项式级时间复杂度：常量阶：O(1);对数阶O(logn);线性阶O(n);线性对数阶：O(nlogn);平方阶：O(n^2)...
// 非多项式阶时间复杂度：指数阶：O(2^n);阶乘阶：O(n!)


// 空间复杂度：
// 空间复杂度就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的
// 增长关系。
